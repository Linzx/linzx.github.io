@R大 专业从事JVM研发，对于JVM理解的深度那是没得说的，可谓首屈一指。但对于面试时被问到Java GC相关问题，大多数面试官对GC的理解深度可能比不得@R大（除非面试的职位也是jvm研发，或者性能调优相关，那就另说）。

我们姑且不论面试官的自身水平问题，当面试官当问出这个问题，很可能是想进一步了解面试者在对Java掌握的前提下，是否对gc有一定理解，是否对技术能进一步挖掘的欲望与能力，而不一定是说gc对接下来的工作紧密相关。有不少多年从事java或android开发工作的人，GC对于他们而言是完全透明的，“一直都在身边，却不曾真正相遇”。

-------------------------------------
接下来回到正题，我认为对于从事Java相关开发的朋友来说，能彻底明白Java GC的这三个问题就够矣：

1. 哪些内存需要GC？（Where）
2. 何时触发GC？（When）
3. 如何进行GC？（How）

一、哪些内存需要GC？

要明白哪些内存需要GC，首先需要明白的便是Java运行时内存模型

如图。

GC针对的内存区是Java堆和方法区：

- Java堆的新生代，一次GC能回收的内存最高；
- Java堆的老年代，一次GC能被回收的内存较低；
- 方法区GC则回收的内存往往是最低（当然也不是绝对的），例如有大量的常量和类不再使用，那么方法区也能回收不少内存。


对于Java堆和方法区，哪些内存会被判断为垃圾内存呢？

回答这个问题前，我们先说说引用计数法和可达性算法

- 引用计数法(referene-counting) ：每个对象有一个引用计数器，当对象被引用一次则计数器加1，当对象引用失效一次则计数器减1，对于计数器为0的对象意味着是垃圾对象，可以被GC回收。
- 可达性算法(GC Roots Tracing)：从GC Roots作为起点开始搜索，那么整个连通图中的对象便都是活对象，对于GC Roots无法到达的对象便成了垃圾回收的对象，随时可被GC回收。

目前比较主流的虚拟机都是采用可达性算法，为什么不采用引用计数法呢？下面通过实例来讲述，

public class GcDemo {
    public static void main(String[] args) {
        GcObject obj1 = new GcObject(); //Step 1
        GcObject obj2 = new GcObject(); //Step 2
 
        obj1.instance = obj2; //Step 3
        obj2.instance = obj1; //Step 4
 
        obj1 = null; //Step 5
        obj2 = null; //Step 6
    }
}
 
class GcObject{
    public Object instance = null;
}

这是《深入理解Java虚拟机》中采用的实例，网上有很多博客也是通过实例来说明，如果采用引用计数算法，则GC无法回收obj1和obj2，而可达性算法则可以有效回收。至于为什么会是这样的呢？从没有见一个真正说清楚的，下面我用几幅图来说明这个问题。




可作为GC Roots的对象：

- 虚拟机栈的栈帧的局部变量表所引用的对象；
- 本地方法栈的JNI所引用的对象；
- 方法区的静态变量和常量所引用的对象；
- 
二、何时触发GC？（When）

对于Sun公司的HotSpot VM中有两种GC，即Partial GC和Full GC。

1.Full GC：针对对Java堆中的新生代和老年代以及方法区都进行GC整理操作，执行时间较长；
2.Partial GC：只针对部分堆进行GC操作，比如只收集新生代的Young GC,或只收集老年代的Old GC。按需GC，执行时间相对Full GC自然更短。

当新生代的eden空间不足时触发Young GC；当老年代的空间不足时触发Old GC；当显式调用System.gc()或方法区空间不足等情况下触发Full GC。当然不同参数下的各种GC收集器的触发时机可能会略有不同。

三、如何进行GC？（How）

要了解GC策略，需要明白4个经典的GC算法

1. Mark-Sweep（标记-清除）算法：分标记和清除两个阶段，先标记可回收的内存，再对相应内存进行清理。该算法缺点是容易产生内存碎片，优点是效率较高。
2. Copying（复制）算法：将内存划分成等大的A,B两块，先使用内存A，当内存A用完后复制存活对象到内存B，然后清理内存A，同理B用完后复制到A，如此反复操作。该算法缺点内存利用率低，优点是减少内存碎片。
3. Mark-Compact（标记-整理）算法：分标记和整理两个阶段，先标记可回收的内存，再将存活对象向一段移动，然后清理剩余内存。
4. Generational Collection（分代收集）算法：这是JVM主流算法，根据对象存活时间划分为新生代和老年代，新生代往往有大量对象需要被回收，而老年代经得起岁月的洗礼，往往只有少量的对象能被GC回收。根据新生代和老年代的不同特点，往往采用不同的回收算法。比如新生代可采用增强版的Copying算法(分为Eden、From、To三个区域)，而老年代采用Mark-Compact算法。

有了这些GC算法，那么自然而然就产生了GC收集器，常见GC包括Serial、ParNew、CMS以及G1收集器，关于GC收集器就不细说了~~

